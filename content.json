{"meta":{"title":"Mr.Young","subtitle":null,"description":null,"author":"Mr.Young","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java技能之：用注解实现接口映射","slug":"urlmapping","date":"2016-11-08T13:55:38.000Z","updated":"2016-11-08T15:01:08.318Z","comments":true,"path":"2016/11/08/urlmapping/","link":"","permalink":"http://yoursite.com/2016/11/08/urlmapping/","excerpt":"","text":"前景介绍 注解是java1.5之后引入的特性，之前写web应用时通常都是通过在web.xml配置servlet和url的映射，这种情况web应用接口数量庞大不说开发人员通常需要写多个servlet或者是在单个servlet中完成url的判断后再引入到业务逻辑，而注解映射相比显得非常简洁，由于少了xml配置和xml的解析功能使得开发效率也有很大的提升。 关于接口映射这块Spring mvc已经有了很好的实现了，但通常我们自己在开发时通常使用DispatchServlet接收到Request后通常需要根据业务场景完成一些预操作，比如参数校验，请求权限或者安全方面的校验成功之后才通过Handler将请求传递到业务逻辑层，所以学会自己开发接口映射显得尤为重要。完成一个接口映射功能其实非常简单，本文将从下面四个步骤来给大家详细介绍。 定义注解元数据 由于注解是在运行时统一加载的所以RetentionPolicy为RUNTIME，而一个接口通常对应这一类服务的单个方法所以ElementType为Method类型。12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UrlMapping &#123; String url() default &quot;&quot;;&#125; 注解到接口的映射Map的导出类 这里我们用到了Spring框架的实例工厂功能， 通过该功能来加载所有提供服务的类，即实现了Exportable接口的类，然后在类中查找含有UrlMapping注解的方法，通过反射拿到方法的相关信息创建服务调用单位InvocationUnit，最后加入到Map中，而Map的key为请求的Url，即通过UrlMaping注解映射到url变量的值。这里可以通过Spring的MapFactoryBean完成映射键值对的全局共享。到此我们已经拿到了所有的接口映射的Map，最后需要一个RequestHandler来完成接口的调用即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ServiceExporter implements InitializingBean, ApplicationContextAware&#123; private ApplicationContext appContext; private ConcurrentHashMap&lt;String, InvocationUnit&gt; urlMappings; public void afterPropertiesSet() throws Exception &#123; Map&lt;String, Exportable&gt; exportMap = appContext.getBeansOfType(Exportable.class); convert(new ArrayList&lt;Exportable&gt;(exportMap.values())); &#125; public void setApplicationContext(ApplicationContext arg0) throws BeansException &#123; appContext = arg0; &#125; @SuppressWarnings(&quot;rawtypes&quot;) private void convert(List&lt;? extends Exportable&gt; list) &#123; for (Exportable exportable : list) &#123; Class clazz = exportable.getClass(); Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; UrlMapping urlMapping = method.getAnnotation(UrlMapping.class); if(urlMapping == null)&#123; continue; &#125; urlMappings.put(urlMapping.url(), new InvocationUnit(method, clazz, method.getReturnType())); &#125; &#125; &#125; public ConcurrentHashMap&lt;String, InvocationUnit&gt; getUrlMappings() &#123; return urlMappings; &#125; public void setUrlMappings(ConcurrentHashMap&lt;String, InvocationUnit&gt; urlMappings) &#123; this.urlMappings = urlMappings; &#125;&#125; 请求处理器实现这一步很简单对DispatchServlet传递过来的请求通过下面的Handler拿到后，只需要通过request获取请求的url然后在共享的urlMapping中查询对应的服务并通过反射调用服务即可。这里在调用方法的invoke之前会完成request的参数解析功能，解析原理是根据提供服务方法的查询条件类中相关字段名称到HttpServletRequest中查找，所以在定义查询条件类时需要保持http请求参数名和查询条件类中变量一致，这样才能通过反射拿到对应的参数值，对接口返回结果写入到HttpServletResponse中也是一样的道理。123456789101112131415161718192021222324252627282930313233public class HttpRequestHandelr implements Handler&#123; private static Logger logger = Logger.getLogger(HttpRequestHandelr.class.getSimpleName()); private ConcurrentHashMap&lt;String, InvocationUnit&gt; urlMappings; public void handle(HttpServletRequest request, HttpServletResponse response) &#123; String url = (String) request.getAttribute(&quot;url&quot;); InvocationUnit invocationUnit = urlMappings.get(url); if(invocationUnit == null)&#123; logger.info(&quot;url not found:&quot; + url); return; &#125; //parameter validator ... Object result = invocationUnit.invoke(request); if(result != null)&#123; wirteResponse(result, invocationUnit.getReturnType(), request, response); &#125; &#125; private void wirteResponse(Object result, Class&lt;?&gt; returntype, HttpServletRequest request, HttpServletResponse response) &#123; //通过反射拿到返回的结果填充到response中 &#125; public void setUrlMappings(ConcurrentHashMap&lt;String, InvocationUnit&gt; urlMappings) &#123; this.urlMappings = urlMappings; &#125;&#125; InvocationUnit.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class InvocationUnit implements Invoke&#123; private Method method; private Class&lt;?&gt; invocatinoClass; private Object[] params; private Class&lt;?&gt; returnType; public InvocationUnit(Method method, Class&lt;?&gt; invocatinoClass, Class&lt;?&gt; returnType) &#123; this.method = method; this.invocatinoClass = invocatinoClass; this.returnType = returnType; &#125; public Object invoke(HttpServletRequest request) &#123; praseParam(request); try &#123; return method.invoke(invocatinoClass.newInstance(), params); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125; private void praseParam(HttpServletRequest request) &#123; Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); try &#123; Class&lt;?&gt; requestType = paramTypes[0]; Object object = requestType.newInstance(); Field[] fields = requestType.getDeclaredFields(); for (Field field : fields) &#123; String fieldName = field.getName(); field.setAccessible(true); field.set(object, request.getAttribute(fieldName)); &#125; params = new Object[1]; params[0] = object; &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public Method getMethod() &#123; return method; &#125; public void setMethod(Method method) &#123; this.method = method; &#125; public Class&lt;?&gt; getInvocatinoClass() &#123; return invocatinoClass; &#125; public void setInvocatinoClass(Class&lt;?&gt; invocatinoClass) &#123; this.invocatinoClass = invocatinoClass; &#125; public Object[] getParams() &#123; return params; &#125; public void setParams(Object[] params) &#123; this.params = params; &#125; public Class&lt;?&gt; getReturnType() &#123; return returnType; &#125;&#125; 最后不要忘记配置下spring.xml，大功告成，是不是很简单！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]}]}